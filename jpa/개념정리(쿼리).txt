    @ManyToOne(optional = true) : null 허용하는 조인컬럼 생성
    @ManyToOne(optional = false) : null 허용하지 않는 조인컬럼 생성
    @JoinColumn(name = "team_id") // 원하는 조인 컬럼명 설정
        안하면 =>private Team team ; => 오라클 테이블명_기본키명(team_team_id으로 나옴)

@ManyToOne(optional=false)
    1. join ~ on : 자동으로 join 처리 
    
@ManyToOne(optional=false, fetch = FetchType.LAZY)
    1. 외래 키 테이블 정보를 조회하지 않음(조회 X)
    2. 외래 키에 해당하는 객체 탐색 시 => LazyInitializationException 

@OneToMany
    1. @ManyToOne의 상대방 클래스에 작성
    2. 원래 SQL의 외래키 개념과 불균형 발생 => 해결을 위해 양쪽에 객체 관게 설정
    
    1. 외래키 주인 설정 : @OneToMany(mappedBy="team")
    2. 기본적으로는 join 구문을 실행하지 않음 (기본값 : FetchType.LAZY) 
        => join 관계의 테이블에 접근 시 LazyInitializationException 발생
        => 해결법
            (1) 해당 메소드에 @Transactional 붙이기
                본인, join관계의 테이블 접근 시 각각의 select 구문으로 처리
     	    (2) @EntityGraph(attributePaths ={"roles"}, type =EntityGraphType.LOAD)
            (3) left join으로 한꺼번에 처리 -> 잘 사용 X
                @OneToMany(mappedBy="team",FetchType.EAGER)



@OneToOne :
 내부 조인으로 처리 (default)
 FetchType.LAZY 처리 => @Transactional / @EntityGraph (필요할 때만 join 구문 사용)

@OneToOne(mappedBy ="locker")
 외부 조인으로 처리



객체 그래프 탐색

FetchType.EAGER(즉시로딩) : 연관된 객체가 조회하는 시점에 바로 사용
FetchType.LAZY(지연로딩) : 연관된 객체를 실제 사용하는 시점에 데이터베이스 조회


1. 단방향 (@ManyToOne(optional = false))
    - 내부 조인으로 처리
    - 조인 테이블의 정보를 처음부터 가져오는 것이 아니라 필요 시점에 처리한다면?
        => @ManyToOne(optional = false, fetch = FetchType.LAZY) : 해당 테이블 정보만 조회
        => 필요 시점에 조인 테이블 조회시 : LazyInitializationException 
            (1) @Transactional : 원본테이블 select, 조인 테이블 select
            (2) @EntityGraph

2. 양방향 @ManyToOne(optional = false, fetch = FetchType.LAZY) / @OneToMany(mappedBy = "team")
    - @OneToMany(mappedBy = "team") : FetchType.LAZY 방식임

---------------------------------------------------

3. 단방향 (@OneToOne(optional = false))
    - 내부 조인으로 처리 : FetchType:EAGER

4. 양방향 (@OneToOne(optional = false, fetch =FetchType.LAZY) / @OneToOne(mappedBy="locker"))
    - 외래키 => 원 테이블 접근시 left join 처리


---------------------------------------------------

영속성 관리
=> 내부적으로 Persistence Context를 이용해 관리함

Persistence Context
1차 캐시 : 조회한 엔티티를 저장, 같은 엔티티 조회시 재 쿼리 실행 방지
변경감지 : Dirty Check (값 변경 시 update 구문 실행)
엔티티 동일성 보장 / 라이프 사이클(New, Managed, Removed, Detached) 관리
지연 로딩(Lazy Loading) - 프록시 유지

부모 / 자식
@OneToMany(mappedBy = "parent", cascade = { CascadeType.PERSIST, CascadeType.REMOVE }, orphanRemoval = true)

cascade : 하나의 엔티티에 발생하는 과정을 다른 엔티티에도 전파

CascadeType.PERSIST : 부모 삽입 시 자식도 삽입
코드 상은 ArrayList에 자식 추가 => 부모만 save()

CascadeType.REMOVE : 부모 삭제 시 자식도 삭제
코드 => 부모만 제거

orphanRemoval = true : 고아 객체를 제거
코드 상 부모 엔티티 컬렉션에서 자식 엔티티의 참조만 제거 => 부모만 save()
p.getChilds().remove(index: 0);